<?php

/**
 * @file
 * Adapts core shopping cart features for Commerce Marketplace.
 */

/**
 * Implements hook_views_api().
 */
function commerce_marketplace_cart_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_marketplace_cart') . '/includes/views',
  );
}

/**
 * Implements hook_menu_alter().
 */
function commerce_marketplace_cart_menu_alter(&$items) {
  $items['cart']['page callback'] = 'commerce_marketplace_cart_view';
  $items['checkout']['page callback'] = 'commerce_marketplace_cart_checkout_router';
}

/**
 * Redirects invalid checkout attempts or displays the checkout form if valid.
 *
 * Overrides commerce_cart_checkout_router() to check quantity of all orders
 * in the order group.
 *
 * @see commerce_cart_checkout_router()
 * @see commerce_marketplace_cart_menu_alter()
 * @see commerce_cart_menu()
 */
function commerce_marketplace_cart_checkout_router() {
  global $user;

  // If no shopping cart order could be found, redirect away from checkout.
  if (
    !($orders = commerce_marketplace_cart_order_load_multiple($user->uid))
    || !commerce_marketplace_order_quantity($orders)
  ) {
    drupal_set_message(t('Add some items to your cart and then try checking out.'));
    drupal_goto(variable_get('commerce_checkout_empty_redirect', 'cart'));
  }

  $order = reset($orders);
  drupal_goto('checkout/' . $order->order_id);
}

/**
 * Displays the shopping cart form and associated information, providing option
 * to display a view of line items from multiple user's orders (for multiple
 * stores).
 *
 * Overrides commerce_cart_view().
 *
 * @see commerce_cart_view()
 */
function commerce_marketplace_cart_view() {
  global $user;

  // Default to displaying an empty message.
  $content = theme('commerce_cart_empty_page');

  // First check to make sure we have a valid order.
  if ($orders = commerce_marketplace_cart_order_load_multiple($user->uid)) {

    // Only show the cart form if we found product line items.
    $quantity = commerce_marketplace_order_quantity($orders);
    if ($quantity > 0) {

      // Order ID view contextual filter should be a string
      // listing all order IDs separated by a comma.
      $order_ids = implode(',', array_keys($orders));

      // Add the form for editing the cart contents.
      $content = commerce_embed_view('commerce_cart_form', 'default', array($order_ids), 'cart');
    }
  }

  return $content;
}

/**
 * Implements hook_block_view_alter().
 *
 * Alters 'Shopping cart' block to display all non-empty orders from the order
 * group.
 *
 * @see commerce_cart_block_view()
 */
function commerce_marketplace_cart_block_view_alter(&$data, $block) {
  global $user;

  if ($block->module == 'commerce_cart' && $block->delta == 'cart') {
    // Default to an empty cart block message.
    $content = theme('commerce_cart_empty_block');

    // First check to ensure there are products in the shopping cart.
    if ($orders = commerce_marketplace_cart_order_load_multiple($user->uid)) {
      foreach ($orders as $order) {
        $wrapper = entity_metadata_wrapper('commerce_order', $order);

        // If there are no products in the cart...
        if (commerce_line_items_quantity($wrapper->commerce_line_items, commerce_product_line_item_types()) <= 0) {
          unset($orders[$order->order_id]);
        }
      }

      if (!empty($orders)) {
        // Order ID view contextual filter should be a string
        // listing all order IDs separated by a comma.p
        $order_ids = implode(',', array_keys($orders));

        // Build the variables array to send to the cart block template.
        $variables = array(
          'contents_view' => commerce_embed_view('commerce_cart_block', 'defaults', array($order_ids), $_GET['q']),
        );

        $content = theme('commerce_cart_block', $variables);
      }
    }

    $data['content'] = $content;
  }
}

/**
 * Implements hook_user_login().
 * Extends commerce_cart_user_login().
 *
 * When a user logs into the site, if they have a shopping cart orders
 * they should all be updated to belong to their user account.
 */
function commerce_marketplace_cart_user_login(&$edit, $account) {
  // Get the user's anonymous shopping cart orders if any exists.
  if ($orders = commerce_marketplace_cart_order_load_multiple()) {
    // Convert them to an authenticated cart.
    foreach ($orders as $order) {
      // Last user order (with ID == commerce_cart_order_id()) will be updated
      // by commerce_cart_user_login(), so no need to do it here too.
      if ($order->order_id != commerce_cart_order_id()) {
        commerce_cart_order_convert($order, $account);
      }
    }
  }
}

/**
 * Extends commerce_cart_order_load().
 *
 * Loads the most recent shopping cart order for the specified user and
 * specified store.
 */
function commerce_marketplace_cart_order_load($uid = 0, $conditions = array()) {
  $orders = commerce_marketplace_cart_order_load_multiple($uid, $conditions);
  return reset($orders);
}

/**
 * Loads all shopping cart orders for the specified user and specified store.
 *
 * Extends commerce_cart_order_load().
 *
 * @see commerce_cart_order_load()
 */
function commerce_marketplace_cart_order_load_multiple($uid = 0, $conditions = array()) {
  // Retrieve the order ID for the specified user's current shopping cart.
  $order_ids = commerce_marketplace_cart_order_ids($uid, $conditions);

  // If a valid cart order ID exists for the user, return it now.
  return !empty($order_ids) ? commerce_order_load_multiple($order_ids) : array();
}

/**
 * Returns order group ID for the current user.
 */
function commerce_marketplace_cart_get_current_order_group_id() {
  global $user;
  $orders = commerce_marketplace_cart_order_load_multiple($user->uid);
  if (!empty($orders)) {
    $order = reset($orders);
    return $order->order_group;
  }
  else {
    $last_group = db_select('commerce_order','co')->fields('co', array('order_group'))->orderby('order_group','DESC')->range(0,1)->execute()->fetchField();
    // If no order exists yet, just return 1 as the very first order group ID.
    return $last_group ? ++$last_group : 1;
  }
}

/**
 * Returns the current cart order ID for the given user.
 *
 * Extends commerce_cart_order_id().
 *
 * @see commerce_cart_order_id()
 */
function commerce_marketplace_cart_order_ids($uid = 0, $conditions = array()) {
  $cache_key = md5(json_encode($conditions));

  // Cart order IDs will be cached keyed by $uid and $cache_key generated
  // from other $conditions.
  $cart_order_ids = &drupal_static(__FUNCTION__);

  // Cache the user's cart order ID if it hasn't been set already.
  if (isset($cart_order_ids[$uid][$cache_key])) {
    return $cart_order_ids[$uid][$cache_key];
  }

  // First let other modules attempt to provide a valid order ID for the given
  // uid. Instead of invoking hook_commerce_cart_order_id() directly, we invoke
  // it in each module implementing the hook and return the first valid order ID
  // returned (if any).
  foreach (module_implements('commerce_marketplace_cart_order_id') as $module) {
    $order_ids = module_invoke($module, 'commerce_marketplace_cart_order_ids', $uid, $conditions);

    // If a hook said the user should not have a cart, that overrides any other
    // potentially valid order ID. Return FALSE now.
    if ($order_ids === FALSE) {
      return $cart_order_ids[$uid][$cache_key] = array();
    }

    // If a hook returned a single order ID instead of an array, convert it.
    if (!is_array($order_ids)) {
      $order_ids = array($order_ids);
    }

    // Otherwise only return a valid order IDs.
    if (!empty($order_ids) && is_array($order_ids)) {
      return $cart_order_ids[$uid][$cache_key] = $order_ids;
    }
  }

  // If no order ID exists in anonymous user's session.
  if (!$uid && !commerce_cart_order_session_exists()) {
    return $cart_order_ids[$uid][$cache_key] = array();
  }

  // Create an array of valid shopping cart order statuses.
  $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

  // Start building query to look for user's shopping cart orders.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_order', '=')
    ->propertyCondition('uid', $uid)
    ->propertyCondition('status', $status_ids, 'IN')
    ->propertyOrderBy('order_id', 'DESC');

  // If store ID was provided as FALSE, it means we want orders with products
  // not assigned to any store. And because EFQ does not support IS NULL
  // condition, we have to tag the query here and add the condition in
  // commerce_marketplace_cart_query_null_order_id_alter().

  // Process any additional conditions.
  if (!empty($conditions) && is_array($conditions)) {
    $null_fields = array();
    foreach ($conditions as $field_name => $field_value) {

      // Get database column name from the field information.
      $field = field_info_field($field_name);
      $column = key($field['columns']);

      // If a field should have any specific non-NULL value, we can use
      // standard EFQ functionality.
      if ($field_value !== NULL) {
        $query->fieldCondition($field_name, $column, $field_value, '=');
      }
      // For NULL values though we need some cheating. EntityFieldQuery does not
      // support IS NULL conditions natively (as it doesn't support LEFT JOINs),
      // therefore we need to go around it, as we definitely need it here.
      // Let's then prepare all the data we'll need for adding a LEFT JOIN
      // and relevant IS NULL condition using custom hook_query_TAG_alter()
      // implementation, and tag the query appropriately.
      // Some code borrowed from field_sql_storage_field_storage_query().
      else {
        // Gather all the data that will be needed to add a LEFT JOIN
        // and IS NULL condition later on.
        $tablename_function = ($query->age == FIELD_LOAD_CURRENT) ? '_field_sql_storage_tablename' : '_field_sql_storage_revision_tablename';
        $db_table_name = $tablename_function($field);
        $db_table_alias = _field_sql_storage_tablealias($db_table_name, '_null', $query);
        $db_field_name = _field_sql_storage_columnname($field_name, $column);

        // Add it to the array which we'll attach to the query's metadata.
        $null_fields[$db_table_name] = array(
          'table' => $db_table_name,
          'alias' => $db_table_alias,
          'conditions' => "commerce_order.order_id = $db_table_alias.entity_id",
          'field_name' => $db_field_name,
        );
      }
    }
    // If there were any fields on which we need IS NULL condition, let's add
    // them to the query's metadata and tag the query appropriately. The LEFT
    // JOINs and IS NULL conditions will be added to it in
    // commerce_marketplace_cart_query_cart_order_ids_null_fields_alter().
    if (!empty($null_fields)) {
      $query->addTag('cart_order_ids_null_fields');
      $query->addMetaData('cart_order_ids_null_fields', $null_fields);
    }
  }

  // We want the same behavior as in standard DC - return only orders from the
  // most recent order group.
  $order_group_id = db_query('SELECT MAX(order_group) FROM {commerce_order} WHERE uid = :uid AND status IN (:status_ids) GROUP BY order_group ORDER BY order_group DESC', array(
    ':uid' => $uid,
    ':status_ids' => $status_ids,
  ))->fetchField();
  $query->propertyCondition('order_group', $order_group_id);

  // For anonymous users look for a shopping cart order ID in the session.
  if (!$uid) {
    $query->propertyCondition('order_id', commerce_cart_order_session_order_ids(), 'IN');
  }
  $entities = $query->execute();

  return $cart_order_ids[$uid][$cache_key] = !empty($entities['commerce_order']) ? array_keys($entities['commerce_order']) : FALSE;
}

/**
 * Implements hook_query_TAG_alter() for cart_order_ids_null_fields.
 *
 * Adds extra condition to store select query not supported by default by EFQ.
 *
 * @see commerce_marketplace_cart_order_ids()
 */
function commerce_marketplace_cart_query_cart_order_ids_null_fields_alter(QueryAlterableInterface $query) {
  foreach ($query->getMetaData('cart_order_ids_null_fields') as $null_field) {
    $query->leftJoin($null_field['table'], $null_field['alias'], $null_field['conditions']);
    $query->isNull($null_field['alias'] . '.' . $null_field['field_name']);
  }
}

/**
 * Implements hook_form_alter().
 */
function commerce_marketplace_cart_form_alter(&$form, &$form_state, $form_id) {

  // Override original add to cart form submit callback with our own to make
  // sure new order is created for each store.
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') !== FALSE) {
    $delta = array_search('commerce_cart_add_to_cart_form_submit', $form['#submit']);
    $form['#submit'][$delta] = 'commerce_marketplace_cart_add_to_cart_form_submit';
  }

  // Shopping cart form.
  if (strpos($form_id, 'views_form_commerce_cart_form_') === 0) {
    // If the cart form View shows line items, update submits for both buttons
    // so that when either one is used, statuses of all orders are updated.
    $view = reset($form_state['build_info']['args']);
    if (!empty($view->result)) {
      // Shopping cart: Update cart button - update
      if (FALSE !== $key = array_search('commerce_cart_line_item_views_form_submit', $form['actions']['submit']['#submit'])) {
        $form['actions']['submit']['#submit'][$key] = 'commerce_marketplace_cart_line_item_views_form_submit';
      }
    }
  }
}

/**
 * Form submit handler: add the selected product to the cart.
 *
 * Overrides commerce_cart_add_to_cart_form_submit().
 *
 * @see commerce_cart_add_to_cart_form_submit()
 */
function commerce_marketplace_cart_add_to_cart_form_submit($form, &$form_state) {
  $product_id = $form_state['values']['product_id'];
  $product = commerce_product_load($product_id);

  // If the line item passed to the function is new...
  if (empty($form_state['line_item']->line_item_id)) {
    // Create the new product line item of the same type.
    $line_item = commerce_product_line_item_new($product, $form_state['values']['quantity'], 0, $form_state['line_item']->data, $form_state['line_item']->type);

    // Allow modules to prepare this as necessary. This hook is defined by the
    // Product Pricing module.
    drupal_alter('commerce_product_calculate_sell_price_line_item', $line_item);

    // Remove line item field values the user didn't have access to modify.
    foreach ($form_state['values']['line_item_fields'] as $field_name => $value) {
      // Note that we're checking the Commerce Cart settings that we inserted
      // into this form element array back when we built the form. This means a
      // module wanting to alter a line item field widget to be available must
      // update both its form element's #access value and the field_access value
      // of the #commerce_cart_settings array.
      if (empty($form['line_item_fields'][$field_name]['#commerce_cart_settings']['field_access'])) {
        unset($form_state['values']['line_item_fields'][$field_name]);
      }
    }

    // Unset the line item field values array if it is now empty.
    if (empty($form_state['values']['line_item_fields'])) {
      unset($form_state['values']['line_item_fields']);
    }

    // Add field data to the line item.
    field_attach_submit('commerce_line_item', $line_item, $form['line_item_fields'], $form_state);

    // Process the unit price through Rules so it reflects the user's actual
    // purchase price.
    rules_invoke_event('commerce_product_calculate_sell_price', $line_item);

    // Only attempt an Add to Cart if the line item has a valid unit price.
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    if (!is_null($line_item_wrapper->commerce_unit_price->value())) {
      // Add the product to the specified shopping cart.
      $form_state['line_item'] = commerce_marketplace_cart_product_add(
        $form_state['values']['uid'],
        $line_item,
        isset($line_item->data['context']['add_to_cart_combine']) ? $line_item->data['context']['add_to_cart_combine'] : TRUE
      );
    }
    else {
      drupal_set_message(t('%title could not be added to your cart.', array('%title' => $product->title)), 'error');
    }
  }
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * Overrides commerce_cart_product_add().
 *
 * @see commerce_cart_product_add()
 */
function commerce_marketplace_cart_product_add($uid, $line_item, $combine = TRUE) {
  // Do not add the line item if it doesn't have a unit price.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  if (is_null($line_item_wrapper->commerce_unit_price->value())) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $store = $line_item_wrapper->commerce_product->commerce_store->value();
  $store_id = !empty($store) ? $store->store_id : NULL;
  // If product is not assigned to any store, we need to check for orders not
  // assigned to any store either, which means passing FALSE as a second param
  // to commerce_marketplace_cart_order_load().
  $order = commerce_marketplace_cart_order_load($uid, $conditions);

  // If no order existed, create one now.
  if (empty($order)) {
    // We need to get order group ID before calling commerce_cart_order_new(),
    // as it will already save a new order with order group ID set to 0.
    $order_group = commerce_marketplace_cart_get_current_order_group_id();
    $order = commerce_cart_order_new($uid);
    $order->order_group = $order_group;
  }

  // Set the incoming line item's order_id.
  $line_item->order_id = $order->order_id;

  // Wrap the order for easy access to field data.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Add store ID to order details.
  foreach ($conditions as $field_name => $field_value) {
    $order_wrapper->$field_name = $field_value;
  }

  // Extract the product and quantity we're adding from the incoming line item.
  $product = $line_item_wrapper->commerce_product->value();
  $quantity = $line_item->quantity;

  // Invoke the product prepare event with the shopping cart order.
  rules_invoke_all('commerce_cart_product_prepare', $order, $product, $line_item->quantity);

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $matching_line_item = NULL;

  // If we are supposed to look for a line item to combine into...
  if ($combine) {
    // Generate an array of properties and fields to compare.
    $comparison_properties = array('type', 'commerce_product');

    // Add any field that was exposed on the Add to Cart form to the array.
    // TODO: Bypass combination when an exposed field is no longer available but
    // the same base product is added to the cart.
    foreach (field_info_instances('commerce_line_item', $line_item->type) as $info) {
      if (!empty($info['commerce_cart_settings']['field_access'])) {
        $comparison_properties[] = $info['field_name'];
      }
    }

    // Allow other modules to specify what properties should be compared when
    // determining whether or not to combine line items.
    drupal_alter('commerce_cart_product_comparison_properties', $comparison_properties);

    // Loop over each line item on the order.
    foreach ($order_wrapper->commerce_line_items as $delta => $matching_line_item_wrapper) {
      // Examine each of the comparison properties on the line item.
      foreach ($comparison_properties as $property) {
        // If any property does not match the same property on the incoming line
        // item...
        if ($matching_line_item_wrapper->{$property}->raw() != $line_item_wrapper->{$property}->raw()) {
          // Continue the loop with the next line item.
          continue 2;
        }
      }

      // If every comparison line item matched, combine into this line item.
      $matching_line_item = $matching_line_item_wrapper->value();
      break;
    }
  }

  // If no matching line item was found...
  if (empty($matching_line_item)) {
    // Save the incoming line item now so we get its ID.
    commerce_line_item_save($line_item);

    // Add it to the order's line item reference value.
    $order_wrapper->commerce_line_items[] = $line_item;
  }
  else {
    // Increment the quantity of the matching line item, update the data array,
    // and save it.
    $matching_line_item->quantity += $quantity;
    $matching_line_item->data = array_merge($line_item->data, $matching_line_item->data);

    commerce_line_item_save($matching_line_item);

    // Clear the line item cache so the updated quantity will be available to
    // the ensuing load instead of the original quantity as loaded above.
    entity_get_controller('commerce_line_item')->resetCache(array($matching_line_item->line_item_id));

    // Update the line item variable for use in the invocation and return value.
    $line_item = $matching_line_item;
  }

  // Save the updated order.
  commerce_order_save($order);

  // Invoke the product add event with the newly saved or updated line item.
  rules_invoke_all('commerce_cart_product_add', $order, $product, $quantity, $line_item);

  // Return the line item.
  return $line_item;
}

/**
 * Submit handler to show the shopping cart updated message.
 *
 * Overrides commerce_cart_line_item_views_form_submit().
 *
 * @see commerce_cart_line_item_views_form_submit()
 */
function commerce_marketplace_cart_line_item_views_form_submit($form, &$form_state) {
  global $user;

  // Process only orders with the 'cart' status type.
  if ($orders = commerce_marketplace_cart_order_load_multiple($user->uid)) {
    foreach ($orders as $group_order) {
      // Reset the status of the order to cart.
      $group_order = commerce_order_status_update($group_order, 'cart', TRUE);

      // Skip saving in the status update and manually save here to force a save
      // even when the status doesn't actually change.
      if (variable_get('commerce_order_auto_revision', TRUE)) {
        $group_order->revision = TRUE;
        $group_order->log = t('Customer updated the order via the shopping cart form.');
      }

      commerce_order_save($group_order);

      // Re-add updated order to the form.
      if ($group_order->order_id == $form_state['order']->order_id) {
        $form_state['order'] = $group_order;
      }
    }
  }

  drupal_set_message(t('Your shopping cart has been updated.'));
}
